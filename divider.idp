/**
 * This is a model of a divider problem, where Participants are allowed to pick their favourite Things. These Things,
 * some of which may have a minimum or maximum number of Participants, should be divided among them, so that each
 * Participant is alotted a single Thing. Things may be mandatory, meaning that at least 1 Participant should be alotted
 * the thing (this may be so if the Things are tasks). Things may also have a minimum and a maximum number of Participants.
 * This is a model of a fair system, where each Participant's happiness is maximized, and unhappiness, if unavoidable,
 * is randomly alotted.
 */
vocabulary DividerVoc {

	type Id isa nat

	// a Participant to the division
	type Participant
	ParticipantId(Participant) : Id
	partial ParticipantName(Participant) : string

	// a Thing to be alotted
	type Thing
	ThingId(Thing) : Id
	partial ThingName(Thing) : string
	partial ThingDescription(Thing) : string

	// whether the Thing is mandatory to be alotted
	Mandatory(Thing)
	// the maximum number of Participants
	partial MaxNbParticipants(Thing) : nat
	// the minimum number of Participants, if it is to be alotted
	partial MinNbParticipants(Thing) : nat

	type Score isa int

	// a Participant's vote for a given Thing models how happy the Participant indicated he would be to be alotted the Thing
	Voted(Participant, Thing, Score)
	// a Participant is Active if he has brought out his vote
	Active(Participant)
	// a Participant's ImplicitScore for a given Thing models how happy the Participant would be to be alotted the Thing
	ParticipantScore(Participant, Thing, Score)

	// the Thing alotted to a Participant
	Alotted(Participant) : Thing

} //DividerVoc

theory DividerTheory : DividerVoc {

	// Active
	{
		! p [Participant] : Active(p) <- ? t [Thing] s [Score] : Voted(p, t, s).
	}

	// ParticipantScore
	{
		// a Participant that has not voted, is happy with any Thing
		! p [Participant] t [Thing] : ParticipantScore(p, t, MAX[:Score]) <- ~Active(p).
		// a Participant that has voted, has indicated his happiness with some Things
		! p [Participant] t [Thing] s [Score] : ParticipantScore(p, t, s) <- Active(p) & Voted(p, t, s).
		// a Participant that has voted, is unhappy with any other Thing
		! p [Participant] t [Thing] : ParticipantScore(p, t, MIN[:Score]) <- Active(p) & ! s [Score] : ~Voted(p, t, s).
	}

	// all Participants are alotted a single thing
	! p [Participant] : ? t [Thing] : Alotted(p) = t.

	// mandatory Things are alotted to at least one Participant
	! t [Thing] : Mandatory(t) => ? p [Participant] : Alotted(p) = t.
	// the maximum number of participants for a Thing is respected
	! t [Thing] n [nat] : MaxNbParticipants(t) = n => #{p [Participant] : Alotted(p) = t} = n.
	// if a Thing is alotted to any participant, the minimum number of participants is respected
	! t [Thing] n [nat] : MinNbParticipants(t) = n => #{p [Participant] : Alotted(p) = t} >= n | ! p [Participant] : Alotted(p) ~= t.

} //DividerTheory

structure exampleStruct : DividerVoc {
	Score = { 1..100 }
	Participant = { P1 ; P2 ; P3 ; P4 ; P5 }
	Thing = { T1 ; T2 }
	Voted = { (P1, T1, 10) ; (P1, T2, 90) ; (P2, T1, 60) ; (P2, T2, 40) ; (P3, T2, 100) ; (P4, T1, 20) ; (P4, T2, 80) }
	Mandatory = { }
	MaxNbParticipants = { T1 -> 4 ; T2 -> 2 }
	MinNbParticipants = { }
}

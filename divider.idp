/**
 * This is a modeling of a divider problem, where Participants are allowed to pick their favourite Things. These Things,
 * some of which may have a minimum or maximum number of Participants, should be divided among them, so that each
 * Participant is allotted a single Thing. Things may be mandatory, meaning that at least 1 Participant should be allotted
 * the thing (this may be so if the Things are tasks). Things may also have a minimum and a maximum number of Participants.
 * This is a modeling of a fair system, where each Participant's happiness is maximized, and unhappiness, if unavoidable,
 * is randomly allotted.
 */

vocabulary DividerVoc {

	// a Participant to the division
	type Participant
	// Id and Name predicates can be added here

	// a Thing to be allotted
	type Thing
	// Id, Name and Description predicates can be added here

	type Score isa int

	// whether the Thing is mandatory to be allotted
	Mandatory(Thing)
	// the maximum number of Participants
	MaxNbParticipants(Thing, nat)
	// the minimum number of Participants, if it is to be allotted
	MinNbParticipants(Thing, nat)

	// a Participant's vote for a given Thing models how happy the Participant indicated he would be to be allotted the Thing
	Voted(Participant, Thing, Score)
	// a Participant is Active if he has brought out his vote
	Active(Participant)
	// a Participant's ImplicitScore for a given Thing models how happy the Participant would be to be allotted the Thing
	ParticipantScore(Participant, Thing, Score)

	// the Thing allotted to a Participant
	Allotted(Participant, Thing)
	FinalScore(Participant, Score)

} //DividerVoc

theory DividerTheory : DividerVoc {

	// Active
	{
		! p [Participant] : Active(p) <- ? t [Thing] s [Score] : Voted(p, t, s).
	}

	// ParticipantScore
	{
		// a Participant that has not voted, is happy with any Thing
		! p [Participant] t [Thing] : ParticipantScore(p, t, MAX[:Score]) <- ~Active(p).
		// a Participant that has voted, has indicated his happiness with some Things
		! p [Participant] t [Thing] s [Score] : ParticipantScore(p, t, s) <- Active(p) & Voted(p, t, s).
		// a Participant that has voted, is unhappy with any other Thing
		! p [Participant] t [Thing] : ParticipantScore(p, t, MIN[:Score]) <- Active(p) & ! s [Score] : ~Voted(p, t, s).
	}

	// FinalScore
	{
		//TODO: update when multiple Things can be allotted to one Participant
		! p [Participant] s [Score] : FinalScore(p, s) <- ? t [Thing] : Allotted(p, t) & ParticipantScore(p, t, s).
	}

	//TODO: update when multiple Things can be allotted to one Participant
	// all Participants are allotted a single thing
	! p [Participant] : ?1 t [Thing] : Allotted(p, t).

	// mandatory Things are allotted to at least one Participant
	! t [Thing] : Mandatory(t) => ? p [Participant] : Allotted(p, t).
	// the maximum number of participants for a Thing is respected
	! t [Thing] n [nat] : MaxNbParticipants(t, n) => #{ p [Participant] : Allotted(p, t) } =< n.
	// if a Thing is allotted to any participant, the minimum number of participants is respected
	! t [Thing] n [nat] : MinNbParticipants(t, n) => #{ p [Participant] : Allotted(p, t) } >= n | ! p [Participant] : ~Allotted(p, t).

} //DividerTheory

term LowestScoreNegated : DividerVoc {
	//TODO: minimizing the max of a negated set is not very clean, should not be necessary
	max{ s [Score] : (? p [Participant] : FinalScore(p, s)) : -s }
	//TODO: below is more readable, but is above more efficient?
	//max{ p [Participant] s [Score] : FinalScore(p, s) : -s }
} //LowestScoreNegated

structure ExampleStruct : DividerVoc {
	Participant = { P1 ; P2 ; P3 ; P4 ; P5 }
	Thing = { T1 ; T2 }
	Score = { 0..100 }
	Mandatory = { }
	MaxNbParticipants = { }
	MinNbParticipants = { }
	Voted = { (P1, T1, 10) ; (P1, T2, 90) ; (P2, T1, 60) ; (P2, T2, 40) ; (P3, T2, 100) ; (P4, T1, 20) ; (P4, T2, 80) }
} //ExampleStruct

procedure main() {
	// TODO: This option is supposed to give a speed up most of the time. I could not find it in the manual...
	stdoptions.splitdefs = false
	local models, success, lowest = minimize(DividerTheory, ExampleStruct, LowestScoreNegated)
	if success == nil then
		print("Your theory is unsatisfiable!")
	else
		print("Success!")
		print(lowest)
		printmodels(models)
	end
} //main()


// vim: set noexpandtab:
